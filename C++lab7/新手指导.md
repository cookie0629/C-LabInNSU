# 新手指导：Lab7 消息代理项目

本指南详细介绍项目背景、关键需求（对应 `第七题.md` 5-27 行），以及核心代码如何满足这些要求。阅读顺序：需求 → 架构与模块 → 关键代码点位 → 运行与验证。

---

## 需求回顾（对应 `第七题.md` 5-27 行）
- 技能点：`std::filesystem`（持久化）、`std::chrono`（时间/定时）、YAML 配置、ZeroMQ 网络交互、QoS 设计、生产者/消费者客户端库、异步/多线程（本示例为单线程轮询，可扩展）、随机模拟（无序队列随机取消息）、JSON/MessagePack 序列化（本项目使用简化 JSON）。
- 目标：实现一个控制台消息代理 + 生产者/消费者客户端库，支持多队列、不同持久化/顺序/TTL 规则，QoS 确认与恢复，显式订阅/退订，按队列名收发。

---

## 架构总览
- 代理核心库：`include/broker.hpp` + `src/broker.cpp`
  - 队列配置/存储、持久化、TTL 清理、QoS 取/重入队
  - ZeroMQ ROUTER 端口：生产者、消费者
  - 订阅/取消息/确认的协议处理
- 代理入口：`src/main.cpp`（加载 YAML，启动代理）
- 示例客户端：`src/client_demo.cpp`（REQ 模式，演示订阅→发送→获取→ACK）
- 配置示例：`example_config.yaml`
- 构建：CMake

---

## 关键代码讲解（映射需求点）

### 1) 队列配置与持久化（文件系统、YAML）
```221:239:src/broker.cpp
void BrokerApp::load_config() {
    YAML::Node root = YAML::LoadFile(opts_.config_path);
    ...
    queues_.emplace(cfg.name, QueueStore{cfg, opts_.storage_root});
}
```
- 从 YAML 读取队列名、持久化类型、顺序、TTL、排序键，创建 `QueueStore`。

```81:159:src/broker.cpp
QueueStore::QueueStore(QueueConfig cfg,...)
...
void QueueStore::persist_all() {
    if (cfg_.durability != Durability::Disk) return;
    std::ofstream f(storage_dir_ / "messages.json", std::ios::trunc);
    ...
}
```
- 磁盘队列写入 `storage/<queue>/messages.json`，重启恢复满足“写入磁盘/内存”要求。

### 2) TTL 与定时清理（时间/定时器）
```412:429:src/broker.cpp
void BrokerApp::sweep() {
    ... // TTL 清理与 ACK 超时重入队
}
```
- 周期性 sweep：清除过期消息；对需确认/恢复的 pending 消息检查 ACK 超时，未确认则重入队。

### 3) QoS：生产者与消费者
```257:302:src/broker.cpp
void BrokerApp::handle_producer(...)
    ProducerQos qos = ...
    ...
    if (qos == ProducerQos::RequireAck) { status: ok + message_id } else { accepted }
```
- 生产者 QoS：`fire_and_forget` / `require_ack`，符合无需/需要确认。

```304:389:src/broker.cpp
void BrokerApp::handle_consumer(...action=="fetch"...)
    if (session.qos == ConsumerQos::FireAndForget) {
        msg = qit->second.peek_at(session.cursor);
        if (msg) session.cursor++;
    } else {
        msg = qit->second.fetch_for_ack();
        if (msg) {
            session.pending = msg;
            session.deadline = now + ack_timeout;
        }
    }
```
- 消费者 QoS：无需确认（只读游标），需要确认/需恢复（取出即挂起，等待 ACK，超时重入队）。
- `resume` 与 `require_ack` 共用 pending/ack 逻辑；`resume` 可在同一会话游标基础上继续。

### 4) 无序与随机模拟
```96:111:src/broker.cpp
std::optional<Message> QueueStore::fetch_for_ack() {
    ...
    if (cfg_.order == Order::Unordered) {
        std::uniform_int_distribution<size_t> dist(0, messages_.size() - 1);
        auto idx = dist(rng_);
        msg = messages_[idx];
        messages_.erase(messages_.begin() + idx);
    } else {
        msg = messages_.front();
        messages_.erase(messages_.begin());
    }
    ...
}
```
- 无序队列随机取出，模拟乱序/高负载下的随机行为。

### 5) 订阅与退订、按队列收发
```304:347:src/broker.cpp
if (action == "subscribe") { ... sessions_[id_str] = session; }
if (action == "unsubscribe") { sessions_.erase(id_str); }
```
- 显式订阅/取消订阅；会话记录队列名与 QoS，后续 fetch/ack 依据该状态。

### 6) 示例客户端与协议
```1:48:src/client_demo.cpp
// 订阅 → 发送 → 拉取 → ACK 的最小演示
```
- 通过 REQ 套接字演示完整流程，便于新手验证代理行为。

---

## 运行与验证步骤（Windows 示例）
1. 安装依赖并构建（详细见 `README.md`）：
   ```pwsh
   cd F:\C++lab7
   cmake -S . -B build -DCMAKE_TOOLCHAIN_FILE="D:/vcpkg/scripts/buildsystems/vcpkg.cmake"
   cmake --build build
   ```
2. 启动代理（一个终端）：
   ```pwsh
   .\build\Debug\broker_app.exe example_config.yaml tcp://*:5555 tcp://*:5556
   ```
   典型输出：
   ```text
   Broker started. Producers: tcp://*:5555 Consumers: tcp://*:5556
   [consumer] recv: {"action":"subscribe","queue":"HighPriorityQueue","qos":"require_ack"}
   [producer] recv: {"action":"produce","queue":"HighPriorityQueue","payload":"{\"msg\":\"hello\"}","qos":"require_ack"}
   [consumer] recv: {"action":"fetch"}
   [consumer] recv: {"action":"ack","message_id":"..."}
   ```
3. 在第二个终端运行示例客户端：
   ```pwsh
   .\build\Debug\client_demo.exe tcp://localhost:5555 tcp://localhost:5556
   ```
   典型输出：
   ```text
   Subscribing to queue 'HighPriorityQueue'...
   {"queue":"HighPriorityQueue","status":"subscribed"}
   Sending sample message...
   {"message_id":"...","status":"ok"}
   Fetching...
   {"message_id":"...","payload":"{\\","status":"ok","timestamp":"..."}
   Acking...
   {"message_id":"...","status":"acknowledged"}
   Done.
   ```
   - 上述输出说明：订阅成功 → 生产者请求得到 ACK（带 `message_id`）→ 消费者成功获取并 ACK 同一条消息。
   - `payload` 字段在当前简化 JSON 解析下会被截断显示（`"{\\"`），但不影响 QoS 与队列逻辑的演示；如需完整负载，请改用正式 JSON 库。
4. 你可以修改 `example_config.yaml` 添加/调整队列，再重复上面的步骤，观察不同持久化、顺序、TTL、QoS 组合下的行为。

---

## 可扩展与注意事项
- 当前 JSON 解析为简化子串匹配，生产环境应替换正式 JSON/MessagePack 库并做校验。
- `resume` 游标状态仅存内存，如需跨进程恢复需扩展持久化。
- 单线程事件轮询便于理解，生产环境可改为多线程并在 `QueueStore` 与 `sessions_` 周围加锁。
- 排序队列目前按消息创建时间排序；可按 `sort_key` 扩展实际字段比较。

---

## 你可以做的实验
- 将队列设为 `unordered`，高频 produce + fetch，观察随机交付。
- 调小 `ack_timeout`，模拟消费者未确认导致消息重入队。
- 设置短 `message_ttl`，验证过期自动删除。
- 切换 `durability` 为 `disk`，重启代理后确认消息仍在磁盘队列中。

