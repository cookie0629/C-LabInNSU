# 任务目标

巩固使用 C++ 标准库元素（时间、文件系统）、通过 ZeroMQ 集成网络组件以及开发用于与代理交互的客户端库的实践技能。

# 学生技能

- 使用文件系统 (std::filesystem)
- 管理时间和定时器 (std::chrono)
- 处理 YAML 配置
- 使用 ZeroMQ 实现网络交互
- 设计支持 QoS（服务质量）的系统
- 为生产者和消费者开发客户端库
- 处理异步事件和多线程
- 使用随机变量模拟场景
- 以 JSON 或 MessagePack 格式序列化数据

# 任务要求

本任务要求编写一个控制台应用程序，实现消息代理以及用于该代理的客户端库。

网络客户端可以是消息生产者和/或消费者。

生产者将消息传递给代理。代理根据队列的既定规则处理来自生产者的消息。连接时，生产者使用控制消息声明所需的 QoS 级别——无需确认消息处理、需要确认消息处理。

消息消费者通过向代理发送相应的控制消息来显式订阅队列和取消订阅队列。连接时，消费者使用控制消息声明所需的 QoS 级别——无需确认消息处理、需要确认消息处理、需恢复消息处理。

生产者和消费者通过队列名称显式地将消息发送到/从某个队列接收消息。

## 组件实现

编写代理代码，根据配置处理消息。代理应用程序应支持多个网络客户端。

为生产者/消费者开发客户端库，包括：

- 通过 ZeroMQ 连接到代理
- 以 JSON 或 MessagePack 格式发送/接收消息（由学生选择）
- 支持指定 QoS 级别
- 处理确认和故障恢复

## 代理配置

代理应用程序应接受一个 YAML 文件，该文件定义：

- 队列名称
- 持久化类型（写入磁盘或在内存中处理）
- 消息处理顺序（FIFO、无顺序、按指定条件排序）
- 消息生存时间（有限制或无限制）

### 配置示例

queues:

\- name: \"HighPriorityQueue\"

durability: \"disk\"

order: \"FIFO\"

message_ttl: 300 \# 5 分钟

\- name: \"LogsQueue\"

durability: \"memory\"

order: \"sorted\"

sort_key: \"timestamp\"

## 网络客户端

### 生产者 QoS

生产者发送消息时指定 QoS 级别：

- **无需代理处理确认** - 对新消息没有控制消息响应
- **需要代理处理确认** - 对新消息有处理通知响应（即消息已传递到队列）

### 消费者 QoS

消费者订阅/取消订阅队列并指定 QoS 级别

#### 无需处理确认

处于此模式的多个消费者可能获得同一条消息。

消费者连接时，其消息读取从队列开头开始，直到队列末尾（参见队列类型以确定队列中消息的组成和顺序）

#### 需要确认

只有处于此模式的一个并发消费者，以及处于"无需处理确认"模式的多个消费者，可以获得此消息。

代理等待来自消费者的处理确认控制消息

- 收到处理确认时 - 消息从队列中删除
- 在规定时间内未收到确认（由客户端订阅时设置） - 消息返回队列。之后到达的确认将被忽略。

消费者连接时，其消息读取从队列开头开始，直到队列末尾（参见队列类型以确定队列中消息的组成和顺序）

#### 需恢复处理

与"需要确认"模式类似，但当此消费者连接时，从其停止的消息处继续读取。

## 消息处理

消息应根据队列规范（顺序、生存时间）进行处理。对于写入磁盘的队列，确保在重启之间保持状态。确保自动删除生存时间已过的消息。

## 消息格式

客户端与代理之间的数据传输应使用 JSON 或 MessagePack 格式（学生选择其中一种）。

## 附加要求

确保代理和客户端库在处理队列时的线程安全。记录关键事件（接收、处理、删除消息）。

# 准备材料

学习 ZeroMQ（发布者/订阅者、请求/回复模式，开发客户端套接字）。在本任务中，ZeroMQ 库充当消息传输的角色——即不要求在实现代理时使用 ZeroMQ 的高级模式。

使用 C++ 的 YAML 解析器（例如 yaml-cpp）。

使用 std::filesystem 管理文件和目录。

多线程编程基础 (std::thread, std::mutex)。

数据序列化：

- C++ 的 JSON 库 ([[nlohmann/json]{.underline}](https://github.com/nlohmann/json))。
- C++ 的 MessagePack 库 ([[msgpack-c]{.underline}](https://github.com/msgpack/msgpack-c))。

## 队列行为规范（参数组合）

每个队列由三个关键参数定义：

- 持久化
- 消息处理顺序
- 消息生存时间

以下是可能的组合及其行为

### 持久化 - 写入磁盘

#### FIFO

消息保存到磁盘并在重启后恢复。

严格按照到达顺序处理。

如果设置了 TTL（生存时间）：消息在时间到期后从磁盘删除。

#### 无顺序

消息写入磁盘，但不保证处理顺序。

如果设置了 TTL：删除根据定时器发生，与顺序无关。

#### 排序

消息保存到磁盘并按指定键（例如时间戳）排序。

处理按排序顺序进行。

TTL：消息即使尚未到达队列顶部，也会根据时间被删除。

### 持久化 - 内存中

#### FIFO

代理重启时消息丢失。

严格按照到达顺序处理。

TTL：时间到期后自动从内存中删除。

#### 无顺序

消息以任意顺序处理。

TTL：删除异步发生，与处理状态无关。

#### 排序

消息在内存中按指定键排序。

代理重启时队列被清除。

TTL：消息即使其队列尚未到达，也会根据时间被删除。

### 特殊场景

#### 无 TTL 的队列

消息无限期存储（对于磁盘队列——直到显式删除）。

#### "排序 + 磁盘 + TTL" 组合

消息在磁盘上排序，但如果 TTL 到期，可能在处理前被删除。

#### "内存中 + 无顺序 + TTL" 队列

对于顺序不重要但需要自动清理的临时数据非常理想。

## 使用随机变量

在实现任务时，建议使用随机数生成来：

- 模拟消息传递延迟。
- 在高负载下测试代理的稳定性。
- 模拟网络或客户端故障。

# 参考资料和参考数据链接

1.  [[ZeroMQ 文档]{.underline}](https://zeromq.org/)
2.  [[yaml-cpp: C++ 的 YAML 解析器]{.underline}](https://github.com/jbeder/yaml-cpp)
3.  [[std::filesystem (C++17)]{.underline}](https://en.cppreference.com/w/cpp/filesystem)
4.  [[C++ 中的时间处理 (std::chrono)]{.underline}](https://en.cppreference.com/w/cpp/chrono)
5.  [[随机数生成 (std::random)]{.underline}](https://en.cppreference.com/w/cpp/numeric/random)
6.  [[nlohmann/json 库]{.underline}](https://github.com/nlohmann/json)
7.  [[msgpack-c 库]{.underline}](https://github.com/msgpack/msgpack-c)