# 新手指导：仓库多线程仿真项目

> 目标：带你从零理解并运行本项目，同时学到题目中提到的多线程同步要点。

## 1. 快速上手（一步一步照做）
1. **准备环境**  
   - 安装 **CMake ≥ 3.16**。  
   - 安装一个支持 **C++20** 的编译器（推荐：Windows 上用 **MSVC 2022**，Linux 用 **GCC 12+** 或 **Clang 15+**）。  
   - 确保命令行能直接执行 `cmake` 和编译器（Windows 推荐使用 “Developer Command Prompt for VS”）。

2. **编译项目**（在项目根目录执行）：
   
   ```bash
   cmake -S . -B build
   cmake --build build
   ```
   - `-S .`：源码目录是当前路径。  
   - `-B build`：生成的中间文件/工程放在 `build/` 目录中。  
   
3. **运行**（Windows 下示例，Debug 配置）：
   ```bash
   ./build/Debug/warehouse_app.exe --fast --duration 5
   ```
   - `--fast`：将 1~5 秒动作缩短到 1~5 毫秒，便于调试。
   - `--duration`：仿真持续秒数，运行结束后输出报告。

运行成功后你将看到两部分中文报告（订单状态 + 搬运工绩效），说明多线程仿真整体正常。

## 2. 模块拆解（这几个文件分别干什么）
| 模块 | 文件 | 功能概述 |
| --- | --- | --- |
| 领域模型 | `include/Domain.h` | 定义货物、托盘、订单、统计结构与 `SimulationConfig` |
| 随机数工具 | `include/RandomGenerator.h/.cpp` | 统一生成题目要求范围内的随机值 |
| 区域资源 | `include/ZoneResources.h`<br>`src/ZoneResources.cpp` | 收货、存储、包装、发货区的资源池与状态 |
| 任务调度 | `include/TaskDispatcher.h`<br>`src/TaskDispatcher.cpp` | 线程安全任务队列，控制并行度 |
| 角色线程 | `include/Loader.h`, `src/Loader.cpp`<br>`include/Manager.h`, `src/Manager.cpp` | 搬运工执行任务；经理生成任务与卡车事件 |
| 仓库主控 | `include/Warehouse.h`, `src/Warehouse.cpp` | 生命周期管理、统计数据、报告生成 |
| 入口 | `src/main.cpp` | 解析参数、启动/停止仿真、打印报告 |

## 3. 代码阅读顺序（新手不迷路）
1. **`Domain.h`**：先理解有哪些实体与统计字段。
2. **`ZoneResources`**：了解仓库各区域的资源限制如何建模。
3. **`TaskDispatcher`**：看任务如何被搬运工线程领取。
4. **`Manager` & `Loader`**：分别理解任务的生成与执行细节，关注 5 秒超时逻辑。
5. **`Warehouse`**：串联所有组件，观察启动/停止/报告逻辑。
6. **`main.cpp`**：查看参数如何影响仿真。

## 4. 关键同步点（多线程“危险区”怎么看）
1. **终端资源池**：`TimedResourcePool::acquire_for` 使用条件变量 + 超时，模拟“5 秒内抢不到终端则放弃/回队列”。
2. **任务并行度**：`TaskDispatcher` 中 `activeLoaders` 的原子计数限制同一任务的最大搬运工数。
3. **共享进度**：
   - 卸货任务的 `UnloadPayload::Shared::index` 确保不同搬运工不会重复处理同一托盘。
   - 拣配任务的 `remaining` map 通过互斥锁保证同一品类剩余量的正确扣减/回滚。
4. **状态报告**：`Warehouse::updateOrderState` 用互斥保护多个计数器，避免竞态。

## 5. 学习建议（怎么用这个项目练多线程）
1. **先跑默认配置**，通过日志结果理解每个阶段的指标变化。
2. **修改参数**（如 `--loaders`, `--managers`, `--duration`）观察吞吐量和报告差异。
3. **阅读注释**：所有关键函数都加了中文注释，配合题目要求对照理解。
4. **断点调试**：在 `Loader::handleUnload` 或 `handlePicking` 设置断点，观察线程切换。
5. **扩展练习**：
   - 增加更多任务种类（例如补货）。
   - 将报告改写为 JSON，以便做可视化。
   - 练习使用已接入的 `std::future/promise` 等待任务完成（见 6.6）。

## 6. 代码逐模块详解

### 6.1 `TaskDispatcher`：任务生命周期
1. **创建**：经理线程调用 `Warehouse::submitTask`，内部直接 `enqueue` 到 `std::deque`（参考 `src/TaskDispatcher.cpp` 开头）。  
2. **分发**：搬运工在 `Loader::run` 内调用 `dispatcher().acquireTask()`，函数会：
   - 用 `std::unique_lock` 拿到互斥量；
   - 在 `cv_.wait` 中阻塞，直到有可执行的任务；
   - 遍历队列，检查 `task->activeLoaders < maxParallelLoaders`，满足条件则 `fetch_add(1)` 并返回。  
3. **完成**：`Loader` 执行完任务后调用 `dispatcher().finishTask(task)`，会 `fetch_sub(1)` 并在任务标记为完成且无活跃搬运工时从队列中移除，同时 `notify_all` 唤醒其他等待线程。

> **调试建议**：在 `acquireTask` 的 while 循环里打断点，观察不同 `Loader` 如何公平地获得任务。

### 6.2 `Loader`：搬运工线程的完整流程
1. **休息记录**：`Loader::run` 开头记录空闲开始/结束时间，并通过 `Warehouse::recordLoaderRest` 累加到统计中。  
2. **任务分支**：根据 `task->kind` 调用三个处理函数：  
   - `handleUnload`：落实 4 步卸货动作。`payload->shared->index` 确保每个托盘只被处理一次；`TimedResourcePool` 用于模拟终端抢占；失败时根据是否“最后一名搬运工”决定放弃或重试。  
   - `handleInventory`：占用存储终端后依次查询 `InventoryRequest::categories`。  
   - `handlePicking`：预定工作台 → 从存储区扣货 → 尝试装车 → 记录订单状态，涉及 `PackingZone`、`StorageZone`、`ShippingZone` 三个模块的协作。  
3. **状态与统计**：任务成功后调用 `recordTaskCompletion`，同时在拣配流程中通过 `Warehouse::updateOrderState`、`markOrderShipped`、`recordOrderCompletion` 更新报告数据。

> **调试建议**：在 `handlePicking` 的 while 循环里打印 `selected` 与 `chunk`，可直观看到不同搬运工如何瓜分订单需求。

### 6.3 `Manager`：任务/卡车生成逻辑
1. **主循环**：`Manager::run` 按照 `Warehouse::operationDelay` 周期执行以下操作：  
   - `scheduleTrucks`：随机生成 `Truck`（10~100 托盘），封装为卸货任务，`maxParallelLoaders` 固定为 3，满足题目“同一辆卡车最多 3 人”要求。  
   - `scheduleOrders`：随机挑选品类与数量，注册订单状态后发布拣配任务，同时限制能参与的搬运工数量。  
   - `scheduleInventory`：随机生成品类列表，发布盘点任务。  
2. **卡车到港**：周期性调用 `shippingZone().registerTruckArrival`，为发货区状态板提供数据来源。

> **调试建议**：可以在 `randomOrder` 中加入固定种子，观察同一订单在仓库内的生命周期。

### 6.4 `Warehouse`：主控与统计
1. **资源初始化**：构造函数中依次创建 `StorageZone`、`PackingZone`、`ShippingZone` 以及四个 `TimedResourcePool`（收货/存储/包装/发货终端）。  
2. **线程启动/停止**：`start()` 创建 `Loader` 与 `Manager` 对象并调用 `start()`，`stop()` 则广播 `dispatcher_.shutdown()` 并逐个线程 `stop()/join()`。  
3. **统计**：  
   - `recordLoaderRest`、`recordTaskCompletion` 用 `std::map<int, LoaderStats>` 记账。  
   - `updateOrderState` 利用 `orderStateMap_` 追踪每个订单当前阶段，并对 `OrderStateCounters` 做增减。  
   - `recordOrderCompletion` 将完成耗时统一放入直方图（以 1 秒为一个 bucket）。  
4. **报告**：`buildReports()` 将上述数据封装到 `WarehouseReports` 供 `main.cpp` 输出。

### 6.6 `future/promise` 任务完成通知（已实装）
- **在哪里**：`Task` 内含 `std::promise<void>` 与共享的 `std::shared_future<void>`，用 `promiseFulfilled` 标志防止重复 `set_value()`。  
- **如何触发**：任务成功时（`Loader::run`）或 `TaskDispatcher::finishTask` 发现任务完成时调用 `set_value()`。  
- **如何获取**：`Warehouse::submitTask` 返回该任务的 `shared_future`，可按需等待：  
  ```cpp
  auto fut = warehouse.submitTask(task);
  fut.wait(); // 或 fut.wait_for(std::chrono::seconds(2));
  ```
- **场景**：在测试或 UI 线程需要精确同步等待某个任务结束时使用；不等待也不影响调度流程。

### 6.5 区域资源：`ZoneResources`
1. **存储区 `StorageZone`**  
   - `placePallet`：加写锁，分配地址后把托盘写入记录。  
   - `takeFromStorage`：遍历记录，消耗目标品类的数量；托盘为空时把地址放回 `freeAddresses_`。  
   - `recordsForCategory` / `totalsByCategory`：通过共享锁提供只读快照，供盘点与报告使用。  
2. **包装区 `PackingZone`**  
   - `reserveWorkstation`：条件变量 + `occupied_` 数组确保同一工作台只被一个任务占用。  
   - `info`：返回工作台的拆垛/包装槽位，用于限制搬运工一次可以搬多少托盘。  
3. **发货区 `ShippingZone`**  
   - `registerTruckArrival` / `registerTruckDeparture`：维护 `docks_` map。  
   - `tryLoad`：等待满足目标城市、容量足够的泊位，装满后自动 `erase`。  
4. **终端资源池 `TimedResourcePool`**  
   - `acquire_for`：如果在超时时间内抢不到资源则返回 false，从而触发“5 秒失败后放弃/回队列”的业务逻辑。  
   - `release`：释放资源并 `notify_one` 唤醒等待者。

## 7. 对应第六题技能要求（第六题.md 第 7-9 行）
> *“能够独立解决 C++ 程序中并行访问同步的典型问题，如死锁和数据竞争；熟悉 C++ 标准库中同步原语的用途；熟悉基于线程的以及 `future + promise` 对的多线程模型。”*

1. **并发同步问题的解决**  
   - **关键位置**：`TaskDispatcher` 与各 `ZoneResource`。  
   - **示例**：`TaskDispatcher::acquireTask` 使用 `std::mutex + std::condition_variable` 控制任务分发，并用 `std::atomic<int>` 限制并发度；`StorageZone` 使用 `std::shared_mutex` 同时支持读写，避免读写冲突。  
   - **学习方法**：阅读 `TaskDispatcher.cpp` 的注释，观察如何避免忙等与竞态，再结合 `Loader::handleUnload` 体会资源争夺时的重试逻辑。

2. **C++ 标准同步原语的熟悉与应用**  
   - **使用集合**：`std::mutex`, `std::lock_guard`, `std::unique_lock`, `std::shared_mutex`, `std::condition_variable`, `std::atomic<bool/int>`, `std::thread`, `std::optional` 等。  
   - **对应代码**：  
     - 终端资源池 `TimedResourcePool::acquire_for` 展示条件变量 + 超时等待用法。  
     - `PackingZone::reserveWorkstation` 演示如何在资源释放时唤醒等待线程。  
     - `Warehouse::updateOrderState` 通过互斥锁保护多个计数器。  
   - **实践建议**：尝试将 `TimedResourcePool` 改写为信号量封装，或增加 `std::scoped_lock`，加深对原语的理解。

3. **线程模型与 future/promise（已实现）**  
   - **当前实现**：每个 `Task` 都带 `promise/future`，`Warehouse::submitTask` 返回 `shared_future` 可 `wait()` / `wait_for()`。  
   - **触发点**：`Loader` 成功完成任务或 `TaskDispatcher::finishTask` 发现任务完成时调用 `set_value()`。  
   - **使用示例**：见 6.6，可在测试或 UI 中同步等待任务完成。  
   - 这样即可覆盖题目对 `future + promise` 模型的要求。

## 8. 常见问题
| 问题 | 解决方法 |
| --- | --- |
| 运行无输出 | 确认仿真持续时间足够（≥1 秒），并检查是否在 release 目录执行 |
| 报告中休息时间为 0 | fast 模式动作非常短，可加长 `--duration` 或关闭 `--fast` |
| 想观察更细节日志 | 可在关键步骤加入 `std::cout` 或使用日志库（如 spdlog） |

祝学习顺利！如果有新的需求（例如 GUI 展示、网络消息队列），可以以本项目为骨架继续扩展。

