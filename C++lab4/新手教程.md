# 格式转换器项目 - 详细新手教程

本教程将详细讲解格式转换器项目的每个部分，帮助新手理解整个项目的架构和实现细节。

## 目录

1. [项目概述](#项目概述)
2. [项目架构](#项目架构)
3. [核心数据结构 - AST](#核心数据结构---ast)
4. [解析器设计](#解析器设计)
5. [JSON解析器详解](#json解析器详解)
6. [TOML解析器详解](#toml解析器详解)
7. [XML解析器详解](#xml解析器详解)
8. [格式转换器](#格式转换器)
9. [主程序流程](#主程序流程)
10. [测试框架](#测试框架)

---

## 项目概述

### 项目目标

这个项目实现了一个格式转换工具，可以在JSON、TOML和XML三种格式之间进行相互转换。

### 核心思想

转换过程分为三个步骤：
1. **解析（Parse）**：将输入格式（如JSON）解析成抽象语法树（AST）
2. **转换（Transform）**：AST是格式无关的中间表示
3. **序列化（Serialize）**：将AST序列化成目标格式（如TOML）

```
JSON输入 → 解析器 → AST → 序列化器 → TOML输出
```

---

## 第四题任务要求与解答总览

本项目是按照 `第四题.md` 中的技术任务书实现的，下面先从整体上说明如何满足那里的四个核心要求，再在后续小节里穿插详细代码讲解。

### 学生技能对应关系

- **能够使用模板功能开发 C++ 应用程序**
  - 使用了 **模板类**：如 `FormatConverter<Format InputFormat, Format OutputFormat>`（见后文“格式转换器”一节），把输入/输出格式都作为编译期枚举模板参数。
  - 使用了 **模板函数**：如 `parseWithFormat<fmt>`、`serializeWithFormat<fmt>`，通过模板参数 `fmt` 在编译期选择正确的解析器和序列化器。
  - 使用了 **模板特化**：`FormatTraits<Format::JSON> / FormatTraits<Format::TOML> / FormatTraits<Format::XML>`，把枚举值映射为对应的解析器/序列化器类型。
- **能够以 C++ 风格处理错误**
  - 解析阶段通过自定义异常类 `ParseException`（继承自 `std::runtime_error`）报告语法错误，并记录出错位置。
  - 运行阶段在 `main` 中统一 `try-catch`：分别捕获 `ParseException` 和通用的 `std::exception`，并将错误信息输出到 `std::cerr`。

### “任务要求”四点在项目中的实现

- **具备构建系统**
  - 项目根目录提供 `CMakeLists.txt`，可以用 CMake 生成 Visual Studio / Ninja / Make 等工程。
  - `build/` 目录下已经包含由 CMake 生成的工程和目标（如 `FormatConverter.exe`、`test_format_converter.exe`），证明构建系统工作正常。
- **具备单元测试**
  - `tests/` 目录中包含多个测试文件：`test_json.cpp`、`test_toml.cpp`、`test_xml.cpp`、`test_converter.cpp` 等，对解析器与模板化转换逻辑进行验证。
  - 自定义了简单的测试宏 `ASSERT`：当条件失败时向 `std::cerr` 输出 `"FAIL: ..."`, 并返回非零值，体现了 C++ 风格的断言与错误报告。
  - `build/` 目录中有 `test_format_converter.exe` 和 CTest 相关配置，可以借助 CTest 自动运行测试。
- **根据技术任务书演示程序行为**
  - 主程序 `main.cpp` 接收两个命令行参数：`<input_format> <output_format>`，完全符合任务中对命令行接口的描述。
  - 程序从 **标准输入 `stdin`** 读取完整文档、调用 `convertDocument` 实现格式转换，并将结果输出到 **标准输出 `stdout`**。
  - 所有错误（未知格式、解析错误、运行时异常）统一输出到 **标准错误流 `stderr`**。
- **需要使用面向对象风格，并运用模板类和模板函数**
  - 使用面向对象的 AST 设计（`ASTNode` 类）和解析器/序列化器基类接口（`Parser<T>` 与 `Serializer<T>`），并通过继承实现 `JSONParser`、`TOMLParser`、`XMLParser` 等具体类。
  - 使用模板类 `FormatConverter` 和模板函数 `parseWithFormat` / `serializeWithFormat` 进行格式无关的转换逻辑抽象，结合运行期调度表 `dispatch[3][3]` 实现既高效又灵活的设计。

在接下来的章节中，你可以带着“第四题”的要求，对照阅读：每一块解析器、序列化器、模板和错误处理的代码，都是对题目要求的一个具体实现。

## 项目架构

### 文件结构说明

```
项目根目录/
├── include/              # 头文件目录
│   ├── ast.h            # AST节点定义
│   ├── parser.h         # 解析器和序列化器基类
│   ├── json_parser.h    # JSON解析器和序列化器声明
│   ├── toml_parser.h    # TOML解析器和序列化器声明
│   ├── xml_parser.h     # XML解析器和序列化器声明
│   └── converter.h      # 格式转换器
├── src/                  # 源文件目录
│   ├── main.cpp         # 主程序入口
│   ├── converter.cpp    # 转换器实现
│   ├── json_parser.cpp  # JSON解析器实现
│   ├── toml_parser.cpp  # TOML解析器实现
│   └── xml_parser.cpp   # XML解析器实现
└── tests/               # 测试文件目录
```

---

## 核心数据结构 - AST

### 什么是AST？

AST（Abstract Syntax Tree，抽象语法树）是一种树形数据结构，用于表示程序或数据的结构。在我们的项目中，AST用于表示解析后的数据，它是格式无关的。

### AST节点类型

让我们看看 `include/ast.h` 中的定义：

```cpp
// AST节点类型枚举
enum class ASTType {
    Null,      // 空值（null）
    Boolean,   // 布尔值（true/false）
    Number,    // 数字（整数或浮点数）
    String,    // 字符串
    Array,     // 数组/列表
    Object     // 对象/映射/表
};
```

### AST值类型定义

```cpp
// AST节点值类型 - 使用std::variant实现类型安全的联合体
using ASTValue = std::variant<
    std::nullptr_t,           // Null类型
    bool,                     // Boolean类型
    double,                   // Number类型（统一使用double）
    std::string,              // String类型
    std::vector<std::shared_ptr<ASTNode>>,  // Array类型：存储AST节点指针的向量
    std::map<std::string, std::shared_ptr<ASTNode>>  // Object类型：键值对映射
>;
```

**代码解释：**
- `std::variant`：C++17的特性，可以存储多种类型中的一种，类似于类型安全的联合体
- `std::shared_ptr<ASTNode>`：智能指针，自动管理内存，避免内存泄漏
- `std::vector`：动态数组，用于存储数组元素
- `std::map`：键值对映射，用于存储对象的属性

### ASTNode类详解

```cpp
class ASTNode {
private:
    ASTType type_;    // 节点类型
    ASTValue value_;  // 节点值（根据类型存储不同的值）

public:
    // 默认构造函数：创建Null节点
    ASTNode() : type_(ASTType::Null), value_(nullptr) {}
    
    // 带类型的构造函数
    explicit ASTNode(ASTType type) : type_(type) {
        // 根据类型初始化对应的默认值
        switch (type) {
            case ASTType::Null:
                value_ = nullptr;
                break;
            case ASTType::Boolean:
                value_ = false;  // 默认false
                break;
            case ASTType::Number:
                value_ = 0.0;     // 默认0.0
                break;
            case ASTType::String:
                value_ = std::string("");  // 默认空字符串
                break;
            case ASTType::Array:
                value_ = std::vector<std::shared_ptr<ASTNode>>();  // 空数组
                break;
            case ASTType::Object:
                value_ = std::map<std::string, std::shared_ptr<ASTNode>>();  // 空对象
                break;
        }
    }
};
```

**代码解释：**
- `explicit`：防止隐式类型转换，必须显式调用构造函数
- `switch`语句：根据类型初始化对应的默认值

### 模板方法 - getValue和setValue

```cpp
// 模板方法获取值
template<typename T>
T getValue() const {
    return std::get<T>(value_);  // 从variant中获取指定类型的值
}

// 模板方法设置值
template<typename T>
void setValue(const T& val) {
    value_ = val;  // 设置variant的值
}
```

**代码解释：**

- `template<typename T>`：模板函数，T可以是variant中的任意类型
- `std::get<T>(value_)`：从variant中获取类型T的值，如果类型不匹配会抛出异常

### 便捷访问方法

```cpp
// 获取布尔值
bool getBoolean() const {
    if (type_ != ASTType::Boolean) {
        throw std::runtime_error("Node is not a boolean");
    }
    return std::get<bool>(value_);
}
```

**代码解释：**
- 先检查节点类型，确保类型匹配
- 如果类型不匹配，抛出异常
- 类型匹配后，从variant中获取值

### 工厂方法

```cpp
// 创建字符串节点的工厂方法
static std::shared_ptr<ASTNode> createString(const std::string& val) {
    auto node = std::make_shared<ASTNode>(ASTType::String);  // 创建String类型节点
    node->setValue<std::string>(val);  // 设置字符串值
    return node;  // 返回智能指针
}
```

**代码解释：**
- `static`：静态方法，可以通过类名直接调用，不需要实例
- `std::make_shared`：创建shared_ptr的便捷方法
- 工厂方法模式：提供统一的创建接口，简化节点创建

---

## 解析器设计

### 解析器基类	

在 `include/parser.h` 中定义了解析器和序列化器的基类：

```cpp
// 解析器基类（模板接口）
template<typename T>
class Parser {
public:
    virtual ~Parser() = default;  // 虚析构函数，确保正确释放派生类
    
    // 从字符串解析
    virtual std::shared_ptr<ASTNode> parse(const std::string& input) = 0;
    
    // 从输入流解析
    virtual std::shared_ptr<ASTNode> parse(std::istream& input) = 0;
};
```

**代码解释：**
- `template<typename T>`：模板类，T是占位符（虽然这里没用到，但保持了设计的一致性）
- `virtual`：虚函数，允许派生类重写
- `= 0`：纯虚函数，必须在派生类中实现
- `= default`：使用编译器生成的默认析构函数

### 序列化器基类

```cpp
// 序列化器基类（模板接口）
template<typename T>
class Serializer {
public:
    virtual ~Serializer() = default;
    
    // 序列化到字符串
    virtual std::string serialize(const std::shared_ptr<ASTNode>& node) = 0;
    
    // 序列化到输出流
    virtual void serialize(const std::shared_ptr<ASTNode>& node, std::ostream& output) = 0;
};
```

**代码解释：**
- 序列化器的作用与解析器相反：将AST转换为字符串格式
- 提供两种输出方式：字符串和输出流

### 错误处理

```cpp
// 解析错误异常类
class ParseException : public std::runtime_error {
public:
    ParseException(const std::string& message, size_t position = 0)
        : std::runtime_error(message), position_(position) {}
    
    size_t getPosition() const { return position_; }

private:
    size_t position_;  // 错误发生的位置
};
```

**代码解释：**
- 继承自`std::runtime_error`：标准异常类
- 保存错误位置：方便调试，知道错误发生在输入的第几个字符

---

## JSON解析器详解

### JSONParser类结构

```cpp
class JSONParser : public Parser<void> {
private:
    std::string input_;  // 输入的JSON字符串
    size_t pos_;         // 当前解析位置（字符索引）
    
    // 辅助方法
    void skipWhitespace();           // 跳过空白字符
    char peek();                      // 查看当前字符（不移动位置）
    char next();                      // 获取当前字符并移动到下一个
    bool expect(char c);              // 期望下一个字符是c，否则抛出异常
    
    // 解析方法
    std::shared_ptr<ASTNode> parseValue();    // 解析值（入口方法）
    std::shared_ptr<ASTNode> parseNull();      // 解析null
    std::shared_ptr<ASTNode> parseBoolean();  // 解析布尔值
    std::shared_ptr<ASTNode> parseNumber();    // 解析数字
    std::shared_ptr<ASTNode> parseString();    // 解析字符串
    std::shared_ptr<ASTNode> parseArray();     // 解析数组
    std::shared_ptr<ASTNode> parseObject();     // 解析对象
};
```

### 核心解析流程

#### 1. 主解析方法

```cpp
std::shared_ptr<ASTNode> JSONParser::parse(const std::string& input) {
    input_ = input;      // 保存输入字符串
    pos_ = 0;            // 初始化位置为0（从第一个字符开始）
    skipWhitespace();    // 跳过开头的空白字符
    
    auto result = parseValue();  // 解析JSON值（可能是对象、数组、字符串等）
    
    skipWhitespace();    // 跳过末尾的空白字符
    
    // 检查是否还有未解析的字符
    if (pos_ < input_.length()) {
        throw ParseException("Unexpected characters after JSON value", pos_);
    }
    
    return result;       // 返回解析结果（AST节点）
}
```

**代码解释：**
- `pos_`：字符索引，从0开始
- `skipWhitespace()`：跳过空格、制表符、换行符等
- `parseValue()`：递归解析的入口点
- 最后检查：确保整个字符串都被解析，没有多余字符

#### 2. 解析值（递归入口）

```cpp
std::shared_ptr<ASTNode> JSONParser::parseValue() {
    skipWhitespace();    // 跳过空白
    char c = peek();     // 查看当前字符，判断值的类型
    
    // 根据第一个字符判断类型
    if (c == 'n') {
        return parseNull();        // "null" 开头
    } else if (c == 't' || c == 'f') {
        return parseBoolean();     // "true" 或 "false" 开头
    } else if (c == '-' || std::isdigit(c)) {
        return parseNumber();      // 数字开头（可能是负数）
    } else if (c == '"') {
        return parseString();      // 双引号开头
    } else if (c == '[') {
        return parseArray();       // 方括号开头
    } else if (c == '{') {
        return parseObject();      // 花括号开头
    } else {
        throw ParseException("Unexpected character: " + std::string(1, c), pos_);
    }
}
```

**代码解释：**
- 这是递归下降解析的核心：根据第一个字符判断类型
- `std::isdigit(c)`：检查字符是否是数字
- 如果都不匹配，抛出异常

#### 3. 解析数字

```cpp
std::shared_ptr<ASTNode> JSONParser::parseNumber() {
    size_t start = pos_;      // 记录开始位置
    bool negative = false;    // 是否为负数
    
    // 处理负号
    if (peek() == '-') {
        negative = true;
        pos_++;
    }
    
    // 解析整数部分
    if (!std::isdigit(peek())) {
        throw ParseException("Expected digit", pos_);
    }
    while (pos_ < input_.length() && std::isdigit(input_[pos_])) {
        pos_++;  // 逐个读取数字字符
    }
    
    // 解析小数部分（如果有）
    if (pos_ < input_.length() && input_[pos_] == '.') {
        pos_++;  // 跳过小数点
        if (!std::isdigit(peek())) {
            throw ParseException("Expected digit after decimal point", pos_);
        }
        while (pos_ < input_.length() && std::isdigit(input_[pos_])) {
            pos_++;
        }
    }
    
    // 解析指数部分（如果有，如 1.23e-4）
    if (pos_ < input_.length() && (input_[pos_] == 'e' || input_[pos_] == 'E')) {
        pos_++;  // 跳过 'e' 或 'E'
        if (pos_ < input_.length() && (input_[pos_] == '+' || input_[pos_] == '-')) {
            pos_++;  // 跳过符号
        }
        if (!std::isdigit(peek())) {
            throw ParseException("Expected digit in exponent", pos_);
        }
        while (pos_ < input_.length() && std::isdigit(input_[pos_])) {
            pos_++;
        }
    }
    
    // 提取数字字符串并转换为double
    std::string numStr = input_.substr(start, pos_ - start);
    double value = std::stod(numStr);  // 字符串转double
    
    return ASTNode::createNumber(value);
}
```

**代码解释：**
- `start`：记录数字开始的位置，用于提取子字符串
- 分三部分解析：整数、小数、指数
- `std::stod()`：C++标准库函数，将字符串转换为double
- 支持格式：`123`、`-45.67`、`1.23e-4`等

#### 4. 解析字符串

```cpp
std::shared_ptr<ASTNode> JSONParser::parseString() {
    expect('"');                    // 期望开始的双引号
    std::string value = parseStringValue();  // 解析字符串内容
    expect('"');                    // 期望结束的双引号
    return ASTNode::createString(value);
}

std::string JSONParser::parseStringValue() {
    std::string result;
    while (pos_ < input_.length()) {
        char c = next();  // 获取下一个字符
        
        if (c == '"') {
            pos_--;  // 回退，让调用者处理引号
            break;   // 遇到结束引号，退出循环
        } else if (c == '\\') {
            // 处理转义字符
            if (pos_ >= input_.length()) {
                throw ParseException("Incomplete escape sequence", pos_);
            }
            char esc = next();  // 获取转义字符
            switch (esc) {
                case '"': result += '"'; break;   // \" → "
                case '\\': result += '\\'; break; // \\ → \
                case '/': result += '/'; break;   // \/ → /
                case 'b': result += '\b'; break; // \b → 退格
                case 'f': result += '\f'; break; // \f → 换页
                case 'n': result += '\n'; break; // \n → 换行
                case 'r': result += '\r'; break; // \r → 回车
                case 't': result += '\t'; break; // \t → 制表符
                case 'u': result += parseUnicode(); break; // \uXXXX → Unicode字符
                default: throw ParseException("Invalid escape sequence", pos_ - 1);
            }
        } else {
            result += c;  // 普通字符，直接添加
        }
    }
    return result;
}
```

**代码解释：**
- `expect('"')`：确保有开始和结束的双引号
- 转义字符处理：`\`后面的字符有特殊含义
- `parseUnicode()`：解析Unicode转义序列（如`\u0041`表示'A'）

#### 5. 解析数组

```cpp
std::shared_ptr<ASTNode> JSONParser::parseArray() {
    expect('[');                    // 期望开始方括号
    auto array = ASTNode::createArray();  // 创建数组节点
    auto& elements = array->getArray();   // 获取数组引用
    
    skipWhitespace();
    
    // 检查是否为空数组 []
    if (peek() == ']') {
        pos_++;
        return array;  // 返回空数组
    }
    
    // 解析数组元素
    while (true) {
        elements.push_back(parseValue());  // 递归解析元素（可能是任意类型）
        skipWhitespace();
        
        if (peek() == ']') {
            pos_++;  // 遇到结束方括号，退出
            break;
        }
        
        expect(',');  // 期望逗号分隔符
    }
    
    return array;
}
```

**代码解释：**
- `auto& elements`：获取数组的引用，可以直接修改
- `push_back()`：向vector添加元素
- 递归调用`parseValue()`：数组元素可以是任意类型（包括嵌套数组和对象）

#### 6. 解析对象

```cpp
std::shared_ptr<ASTNode> JSONParser::parseObject() {
    expect('{');                    // 期望开始花括号
    auto object = ASTNode::createObject();  // 创建对象节点
    auto& members = object->getObject();    // 获取对象引用（map）
    
    skipWhitespace();
    
    // 检查是否为空对象 {}
    if (peek() == '}') {
        pos_++;
        return object;
    }
    
    // 解析键值对
    while (true) {
        skipWhitespace();
        expect('"');                // 键必须是字符串
        std::string key = parseStringValue();  // 解析键名
        expect('"');
        skipWhitespace();
        expect(':');               // 期望冒号
        members[key] = parseValue();  // 解析值并存储到map中
        skipWhitespace();
        
        if (peek() == '}') {
            pos_++;  // 遇到结束花括号，退出
            break;
        }
        
        expect(',');  // 期望逗号分隔符
    }
    
    return object;
}
```

**代码解释：**
- `members[key] = parseValue()`：将键值对存储到map中
- JSON对象要求键必须是字符串（用双引号包围）

### JSON序列化器

```cpp
void JSONSerializer::serializeValue(const std::shared_ptr<ASTNode>& node, 
                                   std::ostream& output, int indent) {
    if (node->isNull()) {
        output << "null";
    } else if (node->isBoolean()) {
        output << (node->getBoolean() ? "true" : "false");
    } else if (node->isNumber()) {
        double num = node->getNumber();
        // 如果是整数，输出整数格式；否则输出浮点数
        if (num == static_cast<long long>(num)) {
            output << static_cast<long long>(num);
        } else {
            output << std::fixed << std::setprecision(15) << num;
        }
    } else if (node->isString()) {
        serializeString(node->getString(), output);  // 需要转义特殊字符
    } else if (node->isArray()) {
        output << "[";
        const auto& arr = node->getArray();
        for (size_t i = 0; i < arr.size(); i++) {
            if (i > 0) output << ",";  // 元素之间用逗号分隔
            serializeValue(arr[i], output, indent);  // 递归序列化元素
        }
        output << "]";
    } else if (node->isObject()) {
        output << "{";
        const auto& obj = node->getObject();
        bool first = true;
        for (const auto& [key, value] : obj) {
            if (!first) output << ",";
            first = false;
            serializeString(key, output);  // 序列化键
            output << ":";
            serializeValue(value, output, indent);  // 递归序列化值
        }
        output << "}";
    }
}
```

**代码解释：**
- 序列化是解析的逆过程：将AST转换回JSON字符串
- 递归调用：处理嵌套结构
- `[key, value]`：C++17的结构化绑定，方便遍历map

---

## TOML解析器详解

### TOML特点

TOML（Tom's Obvious, Minimal Language）是一种配置文件格式，特点：
- 使用 `key = value` 格式
- 支持嵌套表 `[table]`
- 支持数组表 `[[array]]`
- 支持注释 `#`

### TOML解析流程

```cpp
std::shared_ptr<ASTNode> TOMLParser::parse(const std::string& input) {
    input_ = input;
    pos_ = 0;
    auto root = ASTNode::createObject();  // TOML的根必须是对象
    
    while (pos_ < input_.length()) {
        skipWhitespaceAndComments();  // 跳过空白和注释
        
        if (pos_ >= input_.length() || isEndOfLine()) {
            if (pos_ < input_.length()) pos_++;
            continue;  // 跳过空行
        }
        
        char c = peek();
        if (c == '[') {
            pos_++;
            if (peek() == '[') {
                parseArrayTable(root);  // [[array]] 数组表
            } else {
                parseTable(root);       // [table] 普通表
            }
        } else {
            parseKeyValue(root);         // key = value 键值对
        }
        
        skipWhitespaceAndComments();
        if (pos_ < input_.length() && !isEndOfLine()) {
            throw ParseException("Expected newline after statement", pos_);
        }
        if (pos_ < input_.length()) pos_++;
    }
    
    return root;
}
```

**代码解释：**
- TOML是行导向的：每行一个语句
- `[table]`：定义嵌套表
- `[[array]]`：定义数组表（表数组）

### 解析键值对

```cpp
void TOMLParser::parseKeyValue(std::shared_ptr<ASTNode>& root) {
    std::vector<std::string> path = parseKeyPath();  // 解析键路径（可能包含点号）
    skipWhitespace();
    expect('=');
    auto value = parseValue();  // 解析值
    setNestedValue(root, path, value);  // 设置嵌套值
}
```

**代码解释：**
- `parseKeyPath()`：解析键，支持 `table.key` 这样的点号分隔
- `setNestedValue()`：根据路径创建嵌套对象

### 设置嵌套值

```cpp
void TOMLParser::setNestedValue(std::shared_ptr<ASTNode>& root, 
                                 const std::vector<std::string>& path, 
                                 std::shared_ptr<ASTNode> value) {
    std::shared_ptr<ASTNode> current = root;
    
    // 遍历路径（除了最后一个）
    for (size_t i = 0; i < path.size() - 1; i++) {
        auto& obj = current->getObject();
        // 如果路径不存在，创建新对象
        if (obj.find(path[i]) == obj.end()) {
            obj[path[i]] = ASTNode::createObject();
        }
        current = obj[path[i]];  // 进入下一层
    }
    
    // 设置最后一个键的值
    std::string lastKey = path.back();
    current->getObject()[lastKey] = value;
}
```

**代码解释：**
- 处理 `table.key = value`：自动创建 `table` 对象
- 如果路径已存在，直接使用；不存在则创建

---

## XML解析器详解

### XML特点

XML（eXtensible Markup Language）使用标签结构：
- 元素：`<tag>content</tag>`
- 属性：`<tag attr="value">`
- 嵌套结构

### XML解析流程

```cpp
std::shared_ptr<ASTNode> XMLParser::parseElement() {
    expect("<");                    // 期望开始标签
    std::string tagName = parseTagName();  // 解析标签名
    auto element = ASTNode::createObject();  // 每个元素是一个对象
    auto& obj = element->getObject();
    
    // 解析属性
    auto attrs = parseAttributes();
    if (!attrs.empty()) {
        auto attrsNode = ASTNode::createObject();
        for (const auto& [key, value] : attrs) {
            attrsNode->getObject()[key] = ASTNode::createString(value);
        }
        obj["@attributes"] = attrsNode;  // 属性存储在 @attributes 键中
    }
    
    skipWhitespace();
    
    // 检查自闭合标签 <tag/>
    if (peek() == '/' && pos_ + 1 < input_.length() && input_[pos_ + 1] == '>') {
        pos_ += 2;
        obj["@tag"] = ASTNode::createString(tagName);
        return element;
    }
    
    expect(">");
    
    // 解析内容（文本和子元素）
    std::vector<std::shared_ptr<ASTNode>> children;
    std::string textContent;
    
    while (pos_ < input_.length()) {
        skipWhitespace();
        
        if (peek() == '<') {
            if (input_.substr(pos_, 4) == "<!--") {
                parseComment();  // 跳过注释
                continue;
            } else if (pos_ + 1 < input_.length() && input_[pos_ + 1] == '/') {
                // 结束标签 </tag>
                pos_++;  // 跳过 '<'
                pos_++;  // 跳过 '/'
                std::string endTag = parseTagName();
                if (endTag != tagName) {
                    throw ParseException("Mismatched closing tag", pos_);
                }
                expect(">");
                break;  // 退出循环
            } else {
                // 子元素
                if (!textContent.empty()) {
                    // 保存文本内容
                    textContent.erase(0, textContent.find_first_not_of(" \t\n\r"));
                    textContent.erase(textContent.find_last_not_of(" \t\n\r") + 1);
                    if (!textContent.empty()) {
                        children.push_back(ASTNode::createString(textContent));
                    }
                    textContent.clear();
                }
                children.push_back(parseElement());  // 递归解析子元素
            }
        } else {
            textContent += next();  // 收集文本内容
        }
    }
    
    // 保存标签名
    obj["@tag"] = ASTNode::createString(tagName);
    
    // 保存内容
    if (children.size() == 1 && children[0]->isString()) {
        obj["@text"] = children[0];  // 只有文本，直接存储
    } else if (!children.empty()) {
        auto childrenArray = ASTNode::createArray();
        childrenArray->getArray() = children;
        obj["@children"] = childrenArray;  // 多个子节点，存储为数组
    }
    
    return element;
}
```

**代码解释：**
- `@tag`：存储标签名（使用@前缀避免与普通键冲突）
- `@attributes`：存储属性
- `@text`：存储纯文本内容
- `@children`：存储子元素数组

---

## 格式转换器

### 格式枚举

```cpp
enum class Format {
    JSON,
    TOML,
    XML,
    UNKNOWN
};
```

### FormatTraits模板

```cpp
template<Format fmt>
struct FormatTraits;

template<>
struct FormatTraits<Format::JSON> {
    using Parser = JSONParser;
    using Serializer = JSONSerializer;
    static constexpr const char* name = "json";
};

template<>
struct FormatTraits<Format::TOML> {
    using Parser = TOMLParser;
    using Serializer = TOMLSerializer;
    static constexpr const char* name = "toml";
};

template<>
struct FormatTraits<Format::XML> {
    using Parser = XMLParser;
    using Serializer = XMLSerializer;
    static constexpr const char* name = "xml";
};
```

**代码解释：**
- 使用模板特化将每种格式与其解析器、序列化器绑定
- `FormatTraits<Format::JSON>::Parser` 等价于 `JSONParser`

### 模板函数：解析与序列化

```cpp
template<Format fmt>
std::shared_ptr<ASTNode> parseWithFormat(const std::string& input) {
    typename FormatTraits<fmt>::Parser parser;
    return parser.parse(input);
}

template<Format fmt>
std::string serializeWithFormat(const std::shared_ptr<ASTNode>& node) {
    typename FormatTraits<fmt>::Serializer serializer;
    return serializer.serialize(node);
}
```

**代码解释：**
- 通过模板函数，让编译器根据`fmt`选择正确的解析器/序列化器
- `typename`关键字用于告诉编译器`Parser`是类型别名

### 格式解析函数

```cpp
Format parseFormat(const std::string& formatStr) {
    std::string lower;
    lower.reserve(formatStr.size());
    std::transform(formatStr.begin(), formatStr.end(), std::back_inserter(lower),
                   [](unsigned char c) { return static_cast<char>(std::tolower(c)); });
    
    if (lower == "json") return Format::JSON;
    if (lower == "toml") return Format::TOML;
    if (lower == "xml")  return Format::XML;
    return Format::UNKNOWN;
}
```

### 使用模板的格式转换函数

```cpp
std::shared_ptr<ASTNode> parseFromFormat(Format format, const std::string& input) {
    switch (format) {
        case Format::JSON:
            return parseWithFormat<Format::JSON>(input);
        case Format::TOML:
            return parseWithFormat<Format::TOML>(input);
        case Format::XML:
            return parseWithFormat<Format::XML>(input);
        default:
            throw std::runtime_error("Unsupported input format");
    }
}

std::string serializeToFormat(Format format, const std::shared_ptr<ASTNode>& node) {
    switch (format) {
        case Format::JSON:
            return serializeWithFormat<Format::JSON>(node);
        case Format::TOML:
            return serializeWithFormat<Format::TOML>(node);
        case Format::XML:
            return serializeWithFormat<Format::XML>(node);
        default:
            throw std::runtime_error("Unsupported output format");
    }
}
```

**代码解释：**
- `parseWithFormat` 和 `serializeWithFormat` 是模板函数
- `switch` 语句只负责运行期调度，真正的逻辑在编译期确定

### 模板格式转换器

```cpp
template<Format InputFormat, Format OutputFormat>
class FormatConverter {
public:
    std::shared_ptr<ASTNode> parseInput(const std::string& input) const {
        return parseWithFormat<InputFormat>(input);
    }
    
    std::string serializeOutput(const std::shared_ptr<ASTNode>& node) const {
        return serializeWithFormat<OutputFormat>(node);
    }
    
    std::string convert(const std::string& input) const {
        auto ast = parseInput(input);
        return serializeOutput(ast);
    }
};
```

**代码解释：**
- `InputFormat` 与 `OutputFormat` 是非类型模板参数（枚举值）
- 编译期实例化，如 `FormatConverter<Format::JSON, Format::TOML>`
- `convert()` 组合解析与序列化

### 运行期调度：`convertDocument`

```cpp
namespace {
int formatToIndex(Format format) {
    switch (format) {
        case Format::JSON: return 0;
        case Format::TOML: return 1;
        case Format::XML:  return 2;
        default:           return -1;
    }
}

template<Format InputFmt, Format OutputFmt>
std::string convertImpl(const std::string& input) {
    FormatConverter<InputFmt, OutputFmt> converter;
    return converter.convert(input);
}
}

std::string convertDocument(Format inputFormat, Format outputFormat, const std::string& input) {
    const int inputIndex = formatToIndex(inputFormat);
    const int outputIndex = formatToIndex(outputFormat);
    if (inputIndex < 0) throw std::runtime_error("Unsupported input format");
    if (outputIndex < 0) throw std::runtime_error("Unsupported output format");
    
    using ConvertFn = std::string(*)(const std::string&);
    static const ConvertFn dispatch[3][3] = {
        {
            convertImpl<Format::JSON, Format::JSON>,
            convertImpl<Format::JSON, Format::TOML>,
            convertImpl<Format::JSON, Format::XML>
        },
        {
            convertImpl<Format::TOML, Format::JSON>,
            convertImpl<Format::TOML, Format::TOML>,
            convertImpl<Format::TOML, Format::XML>
        },
        {
            convertImpl<Format::XML, Format::JSON>,
            convertImpl<Format::XML, Format::TOML>,
            convertImpl<Format::XML, Format::XML>
        }
    };
    
    return dispatch[inputIndex][outputIndex](input);
}
```

**代码解释：**
- `convertImpl` 是模板函数，返回对应 `FormatConverter` 的结果
- `dispatch` 是 3x3 的函数指针表，编译期生成所有组合
- 运行期只需查表即可完成格式转换

---

## 模板编程详解

### 什么是模板？

模板（Template）是C++的泛型编程机制，允许我们编写与类型无关的代码。在编译时，编译器会根据模板参数生成具体的代码。

**模板的优势：**
1. **类型安全**：编译时检查类型错误
2. **性能优化**：编译期确定类型，避免运行时开销
3. **代码复用**：一份模板代码可以处理多种类型
4. **零成本抽象**：模板展开后通常没有额外开销

### 项目中的模板使用

本项目大量使用了模板来实现格式转换功能。让我们详细分析：

#### 1. 模板特化（Template Specialization）

**FormatTraits模板结构体**

```cpp
// 模板声明：为每种格式定义特征
template<Format fmt>
struct FormatTraits;

// 特化：JSON格式的特征
template<>
struct FormatTraits<Format::JSON> {
    using Parser = JSONParser;           // 类型别名：解析器类型
    using Serializer = JSONSerializer;   // 类型别名：序列化器类型
    static constexpr const char* name = "json";  // 编译时常量
};

// 特化：TOML格式的特征
template<>
struct FormatTraits<Format::TOML> {
    using Parser = TOMLParser;
    using Serializer = TOMLSerializer;
    static constexpr const char* name = "toml";
};

// 特化：XML格式的特征
template<>
struct FormatTraits<Format::XML> {
    using Parser = XMLParser;
    using Serializer = XMLSerializer;
    static constexpr const char* name = "xml";
};
```

**代码解释：**
- `template<Format fmt>`：模板参数是枚举值（非类型模板参数）
- `template<>`：完全特化，为特定格式提供具体实现
- `using Parser = JSONParser`：类型别名，相当于 `typedef JSONParser Parser`
- `static constexpr`：编译时常量，在编译时就能确定值

**使用示例：**
```cpp
// 获取JSON格式的解析器类型
typename FormatTraits<Format::JSON>::Parser parser;  // 等价于 JSONParser parser;

// 获取格式名称
const char* name = FormatTraits<Format::JSON>::name;  // "json"
```

**为什么使用模板特化？**
- 类型安全：编译时就能确定每种格式对应的解析器类型
- 避免错误：如果格式不存在，编译会失败
- 易于扩展：添加新格式只需添加新的特化

#### 2. 模板函数（Template Functions）

**parseWithFormat模板函数**

```cpp
// 模板函数：根据格式解析输入
template<Format fmt>
std::shared_ptr<ASTNode> parseWithFormat(const std::string& input) {
    typename FormatTraits<fmt>::Parser parser;  // 根据fmt选择解析器类型
    return parser.parse(input);
}
```

**代码解释：**
- `template<Format fmt>`：函数模板，fmt是模板参数
- `typename FormatTraits<fmt>::Parser`：从FormatTraits中获取解析器类型
- `typename`关键字：告诉编译器`Parser`是一个类型，不是变量

**编译时实例化：**
```cpp
// 调用时，编译器会生成三个不同的函数：
auto node1 = parseWithFormat<Format::JSON>(input);  // 生成：使用JSONParser
auto node2 = parseWithFormat<Format::TOML>(input);  // 生成：使用TOMLParser
auto node3 = parseWithFormat<Format::XML>(input);   // 生成：使用XMLParser
```

**实际生成的代码（概念上）：**
```cpp
// 编译器会生成类似这样的代码：
std::shared_ptr<ASTNode> parseWithFormat_JSON(const std::string& input) {
    JSONParser parser;
    return parser.parse(input);
}

std::shared_ptr<ASTNode> parseWithFormat_TOML(const std::string& input) {
    TOMLParser parser;
    return parser.parse(input);
}

std::shared_ptr<ASTNode> parseWithFormat_XML(const std::string& input) {
    XMLParser parser;
    return parser.parse(input);
}
```

**serializeWithFormat模板函数**

```cpp
// 模板函数：根据格式序列化输出
template<Format fmt>
std::string serializeWithFormat(const std::shared_ptr<ASTNode>& node) {
    typename FormatTraits<fmt>::Serializer serializer;
    return serializer.serialize(node);
}
```

**使用示例：**
```cpp
auto ast = parseWithFormat<Format::JSON>(jsonString);
std::string toml = serializeWithFormat<Format::TOML>(ast);
```

#### 3. 模板类（Template Classes）

**FormatConverter模板类**

```cpp
// 模板类：格式转换器
template<Format InputFormat, Format OutputFormat>
class FormatConverter {
public:
    // 解析输入（使用InputFormat指定的解析器）
    std::shared_ptr<ASTNode> parseInput(const std::string& input) const {
        return parseWithFormat<InputFormat>(input);
    }
    
    // 序列化输出（使用OutputFormat指定的序列化器）
    std::string serializeOutput(const std::shared_ptr<ASTNode>& node) const {
        return serializeWithFormat<OutputFormat>(node);
    }
    
    // 完整的转换流程：输入 → AST → 输出
    std::string convert(const std::string& input) const {
        auto ast = parseInput(input);
        return serializeOutput(ast);
    }
};
```

**代码解释：**
- `template<Format InputFormat, Format OutputFormat>`：类模板，有两个模板参数
- `InputFormat`和`OutputFormat`是编译时确定的枚举值
- 每个不同的格式组合都会生成一个独立的类

**使用示例：**

```cpp
// 示例1：JSON转TOML
FormatConverter<Format::JSON, Format::TOML> jsonToToml;
std::string json = "{\"name\": \"test\"}";
std::string toml = jsonToToml.convert(json);
// 输出：name = "test"

// 示例2：TOML转XML
FormatConverter<Format::TOML, Format::XML> tomlToXml;
std::string toml = "name = \"test\"";
std::string xml = tomlToXml.convert(toml);
// 输出：<?xml version="1.0"?><root><name>test</name></root>

// 示例3：XML转JSON
FormatConverter<Format::XML, Format::JSON> xmlToJson;
std::string xml = "<root><name>test</name></root>";
std::string json = xmlToJson.convert(xml);
// 输出：{"root":{"name":"test"}}
```

**编译时实例化：**
编译器会为每个格式组合生成独立的类：

```cpp
// 概念上的生成代码：
class FormatConverter_JSON_TOML {
public:
    std::shared_ptr<ASTNode> parseInput(const std::string& input) const {
        JSONParser parser;
        return parser.parse(input);
    }
    
    std::string serializeOutput(const std::shared_ptr<ASTNode>& node) const {
        TOMLSerializer serializer;
        return serializer.serialize(node);
    }
    
    std::string convert(const std::string& input) const {
        auto ast = parseInput(input);
        return serializeOutput(ast);
    }
};

// 还有 FormatConverter_JSON_JSON, FormatConverter_JSON_XML 等...
```

#### 4. 模板在运行期调度中的应用

**convertDocument函数**

虽然模板是编译时的，但我们需要在运行时根据用户输入选择格式。解决方案是使用函数指针表：

```cpp
namespace {
    // 辅助函数：格式转索引
    int formatToIndex(Format format) {
        switch (format) {
            case Format::JSON: return 0;
            case Format::TOML: return 1;
            case Format::XML:  return 2;
            default:           return -1;
        }
    }
    
    // 模板函数：实现具体的转换
    template<Format InputFmt, Format OutputFmt>
    std::string convertImpl(const std::string& input) {
        FormatConverter<InputFmt, OutputFmt> converter;  // 实例化模板类
        return converter.convert(input);
    }
}

// 运行期调度函数
std::string convertDocument(Format inputFormat, Format outputFormat, 
                           const std::string& input) {
    const int inputIndex = formatToIndex(inputFormat);
    const int outputIndex = formatToIndex(outputFormat);
    
    // 函数指针表：3x3的二维数组
    using ConvertFn = std::string(*)(const std::string&);
    static const ConvertFn dispatch[3][3] = {
        // JSON行
        {
            convertImpl<Format::JSON, Format::JSON>,  // JSON → JSON
            convertImpl<Format::JSON, Format::TOML>,   // JSON → TOML
            convertImpl<Format::JSON, Format::XML>    // JSON → XML
        },
        // TOML行
        {
            convertImpl<Format::TOML, Format::JSON>,  // TOML → JSON
            convertImpl<Format::TOML, Format::TOML>,  // TOML → TOML
            convertImpl<Format::TOML, Format::XML>    // TOML → XML
        },
        // XML行
        {
            convertImpl<Format::XML, Format::JSON>,    // XML → JSON
            convertImpl<Format::XML, Format::TOML>,   // XML → TOML
            convertImpl<Format::XML, Format::XML>      // XML → XML
        }
    };
    
    // 通过索引查找对应的转换函数并调用
    return dispatch[inputIndex][outputIndex](input);
}
```

**代码解释：**
- `convertImpl<Format::JSON, Format::TOML>`：模板函数实例化，生成具体的函数
- `static const`：静态常量，只初始化一次，存储在程序的静态数据区
- `dispatch[3][3]`：3x3的函数指针表，覆盖所有格式组合
- `dispatch[inputIndex][outputIndex](input)`：通过索引查找并调用对应的转换函数

**工作流程：**
```
用户输入: "json" "toml"
    ↓
parseFormat("json") → Format::JSON (索引0)
parseFormat("toml") → Format::TOML (索引1)
    ↓
dispatch[0][1] → convertImpl<Format::JSON, Format::TOML>
    ↓
FormatConverter<Format::JSON, Format::TOML> converter
    ↓
converter.convert(input)
    ↓
返回TOML格式的字符串
```

#### 5. 模板的优势对比

**不使用模板的传统方法：**

```cpp
// 传统方法：使用switch语句
std::shared_ptr<ASTNode> parseFromFormat(Format format, const std::string& input) {
    switch (format) {
        case Format::JSON: {
            JSONParser parser;  // 运行时创建对象
            return parser.parse(input);
        }
        case Format::TOML: {
            TOMLParser parser;
            return parser.parse(input);
        }
        // ...
    }
}
```

**问题：**
- 运行时开销：每次调用都要判断格式
- 代码重复：每个分支都有相似的代码
- 难以优化：编译器难以优化switch语句

**使用模板的方法：**

```cpp
// 模板方法：编译时确定
template<Format fmt>
std::shared_ptr<ASTNode> parseWithFormat(const std::string& input) {
    typename FormatTraits<fmt>::Parser parser;  // 编译时确定类型
    return parser.parse(input);
}
```

**优势：**
- 零运行时开销：类型在编译时确定
- 代码复用：一份模板代码处理所有格式
- 易于优化：编译器可以内联和优化

#### 6. 实际使用示例

**示例1：直接使用模板类**

```cpp
#include "converter.h"

int main() {
    // 创建JSON到TOML的转换器
    FormatConverter<Format::JSON, Format::TOML> converter;
    
    std::string json = R"({"name": "Alice", "age": 30})";
    std::string toml = converter.convert(json);
    
    std::cout << toml << std::endl;
    // 输出：
    // name = "Alice"
    // age = 30
    
    return 0;
}
```

**示例2：使用模板函数**

```cpp
#include "converter.h"

int main() {
    std::string json = R"({"name": "Bob"})";
    
    // 使用模板函数解析
    auto ast = parseWithFormat<Format::JSON>(json);
    
    // 使用模板函数序列化
    std::string xml = serializeWithFormat<Format::XML>(ast);
    
    std::cout << xml << std::endl;
    // 输出：
    // <?xml version="1.0"?>
    // <root><name>Bob</name></root>
    
    return 0;
}
```

**示例3：在测试中使用模板**

```cpp
// tests/test_converter.cpp
void testTemplateConverter() {
    // 测试所有格式组合
    std::string json = "{\"test\": 42}";
    
    // JSON → TOML
    FormatConverter<Format::JSON, Format::TOML> jsonToToml;
    std::string toml = jsonToToml.convert(json);
    assert(!toml.empty());
    
    // JSON → XML
    FormatConverter<Format::JSON, Format::XML> jsonToXml;
    std::string xml = jsonToXml.convert(json);
    assert(!xml.empty());
    
    // TOML → JSON
    FormatConverter<Format::TOML, Format::JSON> tomlToJson;
    std::string json2 = tomlToJson.convert("test = 42");
    assert(!json2.empty());
}
```

#### 7. 模板元编程技巧

**constexpr if（C++17）**

虽然本项目没有使用，但可以这样优化：

```cpp
template<Format fmt>
std::string serializeWithFormat(const std::shared_ptr<ASTNode>& node) {
    if constexpr (fmt == Format::JSON) {
        JSONSerializer serializer;
        return serializer.serialize(node);
    } else if constexpr (fmt == Format::TOML) {
        TOMLSerializer serializer;
        return serializer.serialize(node);
    } else if constexpr (fmt == Format::XML) {
        XMLSerializer serializer;
        return serializer.serialize(node);
    }
}
```

**代码解释：**
- `if constexpr`：编译时if，不满足条件的分支不会编译
- 更灵活，但需要C++17支持

**类型特征（Type Traits）**

```cpp
// 检查类型是否是解析器
template<typename T>
struct is_parser : std::false_type {};

template<>
struct is_parser<JSONParser> : std::true_type {};

template<>
struct is_parser<TOMLParser> : std::true_type {};

template<>
struct is_parser<XMLParser> : std::true_type {};

// 使用
static_assert(is_parser<JSONParser>::value, "JSONParser is a parser");
```

#### 8. 模板的编译过程

**步骤1：模板定义**
```cpp
template<Format fmt>
std::shared_ptr<ASTNode> parseWithFormat(const std::string& input) {
    typename FormatTraits<fmt>::Parser parser;
    return parser.parse(input);
}
```

**步骤2：模板实例化**
```cpp
// 代码中调用
auto node = parseWithFormat<Format::JSON>(input);
```

**步骤3：编译器生成代码**
```cpp
// 编译器生成（概念上）
std::shared_ptr<ASTNode> parseWithFormat_JSON(const std::string& input) {
    JSONParser parser;  // 类型已确定
    return parser.parse(input);
}
```

**步骤4：链接**
所有实例化的模板函数被链接到最终的可执行文件中。

#### 9. 总结

**本项目中的模板使用：**

1. **FormatTraits模板特化**：将格式枚举映射到具体的解析器/序列化器类型
2. **parseWithFormat模板函数**：根据格式选择解析器
3. **serializeWithFormat模板函数**：根据格式选择序列化器
4. **FormatConverter模板类**：封装格式转换逻辑
5. **convertImpl模板函数**：实现具体的转换

**模板的优势：**
- ✅ 类型安全：编译时检查
- ✅ 性能优化：零运行时开销
- ✅ 代码复用：一份代码处理多种情况
- ✅ 易于扩展：添加新格式只需添加特化

**学习建议：**
1. 理解模板的基本语法
2. 掌握模板特化的概念
3. 理解编译时多态vs运行时多态
4. 通过实际代码理解模板的实例化过程
5. 尝试添加新的格式支持，练习模板的使用

---

## 主程序流程

### main函数详解

```cpp
int main(int argc, char* argv[]) {
    // 1. 检查命令行参数
    if (argc != 3) {
        std::cerr << "Usage: " << (argc > 0 ? argv[0] : "converter") 
                  << " <input_format> <output_format>" << std::endl;
        std::cerr << "Supported formats: json, toml, xml" << std::endl;
        return 1;  // 返回错误码
    }
    
    // 2. 解析输入和输出格式
    Format inputFormat = parseFormat(argv[1]);   // 第一个参数：输入格式
    Format outputFormat = parseFormat(argv[2]);  // 第二个参数：输出格式
    
    // 3. 验证格式
    if (inputFormat == Format::UNKNOWN) {
        std::cerr << "Error: Unknown input format: " << argv[1] << std::endl;
        return 1;
    }
    
    if (outputFormat == Format::UNKNOWN) {
        std::cerr << "Error: Unknown output format: " << argv[2] << std::endl;
        return 1;
    }
    
    try {
        // 4. 从stdin读取输入
        std::string input;
        std::string line;
        while (std::getline(std::cin, line)) {
            if (!input.empty()) {
                input += "\n";  // 保留换行符
            }
            input += line;
        }
        
        // 5. 移除可能的BOM标记（UTF-8 BOM）
        if (input.length() >= 3 && 
            static_cast<unsigned char>(input[0]) == 0xEF &&
            static_cast<unsigned char>(input[1]) == 0xBB &&
            static_cast<unsigned char>(input[2]) == 0xBF) {
            input = input.substr(3);  // 跳过BOM
        }
        
        // 6. 使用模板化调度进行转换
        std::string output = convertDocument(inputFormat, outputFormat, input);
        
        // 7. 输出到stdout
        std::cout << output;
        
        return 0;  // 成功
    } catch (const ParseException& e) {
        std::cerr << "Parse error: " << e.what() << std::endl;
        return 1;
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }
}
```

**代码解释：**
- `argc`：命令行参数个数（包括程序名）
- `argv`：命令行参数数组
- `std::cin`：标准输入流
- `std::cout`：标准输出流
- `std::cerr`：标准错误流（用于错误信息）
- BOM处理：Windows可能添加UTF-8 BOM标记，需要移除

### 数据流

```
命令行参数 → 格式解析 → stdin读取 → convertDocument(模板调度) → stdout输出
```

---

## 测试框架

### 测试宏定义

```cpp
#define ASSERT(condition, message) \
    do { \
        if (!(condition)) { \
            std::cerr << "FAIL: " << message << std::endl; \
            return 1; \
        } \
    } while(0)
```

**代码解释：**
- `do...while(0)`：确保宏可以像函数一样使用（可以加分号）
- 如果条件不满足，输出错误信息并返回1（表示测试失败）

### 测试示例

```cpp
int testJSON() {
    std::cout << "Testing JSON Parser and Serializer..." << std::endl;
    int failures = 0;
    
    try {
        // 测试1: 解析简单字符串
        {
            JSONParser parser;
            auto node = parser.parse("\"hello\"");
            ASSERT(node->isString(), "Should parse string");
            ASSERT(node->getString() == "hello", "String value should match");
        }
        
        // 测试2: 解析数字
        {
            JSONParser parser;
            auto node = parser.parse("42");
            ASSERT(node->isNumber(), "Should parse number");
            ASSERT(node->getNumber() == 42.0, "Number value should match");
        }
        
        // ... 更多测试
        
        std::cout << "  All JSON tests passed!" << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "  JSON test failed with exception: " << e.what() << std::endl;
        failures++;
    }
    
    return failures;  // 返回失败数量
}
```

**代码解释：**
- 每个测试用例用花括号包围：创建独立的作用域
- `ASSERT`：检查条件，失败则返回
- 异常处理：捕获异常，记录失败

---

## 总结

### 关键概念

1. **AST（抽象语法树）**：格式无关的中间表示
2. **解析器**：将文本转换为AST
3. **序列化器**：将AST转换为文本
4. **递归下降解析**：递归调用解析方法
5. **智能指针**：自动内存管理

### 设计模式

1. **工厂模式**：`ASTNode::createXXX()` 方法
2. **模板模式**：`Parser` 和 `Serializer` 基类
3. **策略模式**：根据格式选择不同的解析器

### 学习建议

1. 从AST开始理解：这是整个项目的核心
2. 理解JSON解析器：最简单，容易理解
3. 对比不同解析器：理解它们的共同点和差异
4. 运行测试：观察实际行为
5. 尝试修改：添加新功能或修复bug

### 扩展方向

1. 添加新格式支持（如YAML）
2. 优化性能（使用更高效的解析算法）
3. 添加更多错误检查
4. 支持格式化输出（美化JSON/XML）

---

希望这个教程能帮助你理解整个项目！如有疑问，可以查看代码注释或运行测试来验证理解。

